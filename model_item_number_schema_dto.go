/*
AVACloud API 1.51.0

AVACloud API specification

API version: 1.51.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package avaclient

import (
	"encoding/json"
)

// checks if the ItemNumberSchemaDto type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &ItemNumberSchemaDto{}

// ItemNumberSchemaDto The schema for ItemNumber's in a Project.
type ItemNumberSchemaDto struct {
	// The count of tiers in the ItemNumberSchema
	TotalLength int32 `json:"totalLength"`
	// The collection of tiers for this ItemNumberSchema.
	Tiers []ItemNumberSchemaTierDto `json:"tiers,omitempty"`
	// The separator to use for separiting the different levels in an ItemNumber. Defaults to DEFAULT_SEPARATOR, which is a point '.'. Setting this to a space or other whitespaces is discouraged, as this might not work correct in all situations and item numbers could be displayed not as intended. This can not be set to an empty or null string, trying that will default to the DEFAULT_SEPARATOR. If a value is set that has a different length than one '1', the DEFAULT_SEPARATOR will be used instead. You should also not use values for the separator that are also valid for the item numbers themselves, as that might also lead to incorrect results
	Separator *string `json:"separator,omitempty"`
	// This string is used to fill (left-pad) item numbers. For example, if a tier has a length of '4' but the given item number is '12', with a Filler of '0', then the final item number will be represented as '0'. This must be a single character string, if a value is given where the Length property does not evaluate to '1', the DEFAULT_FILLER '0' is used. A space is fine to use. You should ensure that you use a value different than Separator, as that might produce unexpected results. No attempt is done by the code to recover from such ambiguous configurations.
	Filler *string `json:"filler,omitempty"`
	// This is just a string property that can optionally be used to store additional data for this ItemNumberSchema, e.g. an identification or a type. It does not have any influence over how item numbers are generated, and is not supported in most exchange formats. However, it is used to store Ã–Norm service specification structure types.
	Identifier *string `json:"identifier,omitempty"`
	// This property indicates if ItemNumbers using this ItemNumberSchema should skip empty group levels. This is commonly only used in GAEB files, where there might be gaps in the hierarchy of elements and position identifiers should be placed at the end of the string representation.
	SkipNonExistingLevelsInPositionItemNumbers bool `json:"skipNonExistingLevelsInPositionItemNumbers"`
	// This string is used only when the property SkipNonExistingLevelsInPositionItemNumbers in this ItemNumberSchema is also set to true. It defaults to DEFAULT_SKIPPED_TIERS_FILLER, but can be set to any string with a lenght of one. Null values or values with a longer length will lead to this property reverting back to the default value. This is used to fill skipped tiers in item numbers where a position is placed in a higher hierarchy level than what would be defined in the Tiers. For example, it could produce an item number like '01.__.02', which would indicate a skipped second level. This should be using different values than Filler and Separator, since that could cause ambiguities in the code that generates the actual item numbers. No attempt is done by the code to recover from such ambiguous configurations.
	SkippedTiersFiller *string `json:"skippedTiersFiller,omitempty"`
	// This is a read-only property that indicates if this schema has a valid structure. It internally just returns the result from IsCorrectlyDefined. This will return if the ItemNumberSchema is correctly defined. For it to be correctly defined, the following conditions must be true: There may only be one lot group, if there is one, it must be at the top. Following lot levels, there may be at least one group level. After the group levels, there must be one position level. After the position level, there may be one index level. If no tiers are defined at all, this will also return false.
	SchemaIsCorrectlyDefined bool `json:"schemaIsCorrectlyDefined"`
	// Defaults to false. If this is disabled, all letters in the ItemNumber string representations will be transformed to their lowercase representation.
	AllowUpperCaseLettering bool `json:"allowUpperCaseLettering"`
}

// NewItemNumberSchemaDto instantiates a new ItemNumberSchemaDto object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewItemNumberSchemaDto(totalLength int32, skipNonExistingLevelsInPositionItemNumbers bool, schemaIsCorrectlyDefined bool, allowUpperCaseLettering bool) *ItemNumberSchemaDto {
	this := ItemNumberSchemaDto{}
	this.TotalLength = totalLength
	this.SkipNonExistingLevelsInPositionItemNumbers = skipNonExistingLevelsInPositionItemNumbers
	this.SchemaIsCorrectlyDefined = schemaIsCorrectlyDefined
	this.AllowUpperCaseLettering = allowUpperCaseLettering
	return &this
}

// NewItemNumberSchemaDtoWithDefaults instantiates a new ItemNumberSchemaDto object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewItemNumberSchemaDtoWithDefaults() *ItemNumberSchemaDto {
	this := ItemNumberSchemaDto{}
	return &this
}

// GetTotalLength returns the TotalLength field value
func (o *ItemNumberSchemaDto) GetTotalLength() int32 {
	if o == nil {
		var ret int32
		return ret
	}

	return o.TotalLength
}

// GetTotalLengthOk returns a tuple with the TotalLength field value
// and a boolean to check if the value has been set.
func (o *ItemNumberSchemaDto) GetTotalLengthOk() (*int32, bool) {
	if o == nil {
		return nil, false
	}
	return &o.TotalLength, true
}

// SetTotalLength sets field value
func (o *ItemNumberSchemaDto) SetTotalLength(v int32) {
	o.TotalLength = v
}

// GetTiers returns the Tiers field value if set, zero value otherwise.
func (o *ItemNumberSchemaDto) GetTiers() []ItemNumberSchemaTierDto {
	if o == nil || IsNil(o.Tiers) {
		var ret []ItemNumberSchemaTierDto
		return ret
	}
	return o.Tiers
}

// GetTiersOk returns a tuple with the Tiers field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *ItemNumberSchemaDto) GetTiersOk() ([]ItemNumberSchemaTierDto, bool) {
	if o == nil || IsNil(o.Tiers) {
		return nil, false
	}
	return o.Tiers, true
}

// HasTiers returns a boolean if a field has been set.
func (o *ItemNumberSchemaDto) HasTiers() bool {
	if o != nil && !IsNil(o.Tiers) {
		return true
	}

	return false
}

// SetTiers gets a reference to the given []ItemNumberSchemaTierDto and assigns it to the Tiers field.
func (o *ItemNumberSchemaDto) SetTiers(v []ItemNumberSchemaTierDto) {
	o.Tiers = v
}

// GetSeparator returns the Separator field value if set, zero value otherwise.
func (o *ItemNumberSchemaDto) GetSeparator() string {
	if o == nil || IsNil(o.Separator) {
		var ret string
		return ret
	}
	return *o.Separator
}

// GetSeparatorOk returns a tuple with the Separator field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *ItemNumberSchemaDto) GetSeparatorOk() (*string, bool) {
	if o == nil || IsNil(o.Separator) {
		return nil, false
	}
	return o.Separator, true
}

// HasSeparator returns a boolean if a field has been set.
func (o *ItemNumberSchemaDto) HasSeparator() bool {
	if o != nil && !IsNil(o.Separator) {
		return true
	}

	return false
}

// SetSeparator gets a reference to the given string and assigns it to the Separator field.
func (o *ItemNumberSchemaDto) SetSeparator(v string) {
	o.Separator = &v
}

// GetFiller returns the Filler field value if set, zero value otherwise.
func (o *ItemNumberSchemaDto) GetFiller() string {
	if o == nil || IsNil(o.Filler) {
		var ret string
		return ret
	}
	return *o.Filler
}

// GetFillerOk returns a tuple with the Filler field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *ItemNumberSchemaDto) GetFillerOk() (*string, bool) {
	if o == nil || IsNil(o.Filler) {
		return nil, false
	}
	return o.Filler, true
}

// HasFiller returns a boolean if a field has been set.
func (o *ItemNumberSchemaDto) HasFiller() bool {
	if o != nil && !IsNil(o.Filler) {
		return true
	}

	return false
}

// SetFiller gets a reference to the given string and assigns it to the Filler field.
func (o *ItemNumberSchemaDto) SetFiller(v string) {
	o.Filler = &v
}

// GetIdentifier returns the Identifier field value if set, zero value otherwise.
func (o *ItemNumberSchemaDto) GetIdentifier() string {
	if o == nil || IsNil(o.Identifier) {
		var ret string
		return ret
	}
	return *o.Identifier
}

// GetIdentifierOk returns a tuple with the Identifier field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *ItemNumberSchemaDto) GetIdentifierOk() (*string, bool) {
	if o == nil || IsNil(o.Identifier) {
		return nil, false
	}
	return o.Identifier, true
}

// HasIdentifier returns a boolean if a field has been set.
func (o *ItemNumberSchemaDto) HasIdentifier() bool {
	if o != nil && !IsNil(o.Identifier) {
		return true
	}

	return false
}

// SetIdentifier gets a reference to the given string and assigns it to the Identifier field.
func (o *ItemNumberSchemaDto) SetIdentifier(v string) {
	o.Identifier = &v
}

// GetSkipNonExistingLevelsInPositionItemNumbers returns the SkipNonExistingLevelsInPositionItemNumbers field value
func (o *ItemNumberSchemaDto) GetSkipNonExistingLevelsInPositionItemNumbers() bool {
	if o == nil {
		var ret bool
		return ret
	}

	return o.SkipNonExistingLevelsInPositionItemNumbers
}

// GetSkipNonExistingLevelsInPositionItemNumbersOk returns a tuple with the SkipNonExistingLevelsInPositionItemNumbers field value
// and a boolean to check if the value has been set.
func (o *ItemNumberSchemaDto) GetSkipNonExistingLevelsInPositionItemNumbersOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return &o.SkipNonExistingLevelsInPositionItemNumbers, true
}

// SetSkipNonExistingLevelsInPositionItemNumbers sets field value
func (o *ItemNumberSchemaDto) SetSkipNonExistingLevelsInPositionItemNumbers(v bool) {
	o.SkipNonExistingLevelsInPositionItemNumbers = v
}

// GetSkippedTiersFiller returns the SkippedTiersFiller field value if set, zero value otherwise.
func (o *ItemNumberSchemaDto) GetSkippedTiersFiller() string {
	if o == nil || IsNil(o.SkippedTiersFiller) {
		var ret string
		return ret
	}
	return *o.SkippedTiersFiller
}

// GetSkippedTiersFillerOk returns a tuple with the SkippedTiersFiller field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *ItemNumberSchemaDto) GetSkippedTiersFillerOk() (*string, bool) {
	if o == nil || IsNil(o.SkippedTiersFiller) {
		return nil, false
	}
	return o.SkippedTiersFiller, true
}

// HasSkippedTiersFiller returns a boolean if a field has been set.
func (o *ItemNumberSchemaDto) HasSkippedTiersFiller() bool {
	if o != nil && !IsNil(o.SkippedTiersFiller) {
		return true
	}

	return false
}

// SetSkippedTiersFiller gets a reference to the given string and assigns it to the SkippedTiersFiller field.
func (o *ItemNumberSchemaDto) SetSkippedTiersFiller(v string) {
	o.SkippedTiersFiller = &v
}

// GetSchemaIsCorrectlyDefined returns the SchemaIsCorrectlyDefined field value
func (o *ItemNumberSchemaDto) GetSchemaIsCorrectlyDefined() bool {
	if o == nil {
		var ret bool
		return ret
	}

	return o.SchemaIsCorrectlyDefined
}

// GetSchemaIsCorrectlyDefinedOk returns a tuple with the SchemaIsCorrectlyDefined field value
// and a boolean to check if the value has been set.
func (o *ItemNumberSchemaDto) GetSchemaIsCorrectlyDefinedOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return &o.SchemaIsCorrectlyDefined, true
}

// SetSchemaIsCorrectlyDefined sets field value
func (o *ItemNumberSchemaDto) SetSchemaIsCorrectlyDefined(v bool) {
	o.SchemaIsCorrectlyDefined = v
}

// GetAllowUpperCaseLettering returns the AllowUpperCaseLettering field value
func (o *ItemNumberSchemaDto) GetAllowUpperCaseLettering() bool {
	if o == nil {
		var ret bool
		return ret
	}

	return o.AllowUpperCaseLettering
}

// GetAllowUpperCaseLetteringOk returns a tuple with the AllowUpperCaseLettering field value
// and a boolean to check if the value has been set.
func (o *ItemNumberSchemaDto) GetAllowUpperCaseLetteringOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return &o.AllowUpperCaseLettering, true
}

// SetAllowUpperCaseLettering sets field value
func (o *ItemNumberSchemaDto) SetAllowUpperCaseLettering(v bool) {
	o.AllowUpperCaseLettering = v
}

func (o ItemNumberSchemaDto) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o ItemNumberSchemaDto) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	// skip: totalLength is readOnly
	if !IsNil(o.Tiers) {
		toSerialize["tiers"] = o.Tiers
	}
	if !IsNil(o.Separator) {
		toSerialize["separator"] = o.Separator
	}
	if !IsNil(o.Filler) {
		toSerialize["filler"] = o.Filler
	}
	if !IsNil(o.Identifier) {
		toSerialize["identifier"] = o.Identifier
	}
	toSerialize["skipNonExistingLevelsInPositionItemNumbers"] = o.SkipNonExistingLevelsInPositionItemNumbers
	if !IsNil(o.SkippedTiersFiller) {
		toSerialize["skippedTiersFiller"] = o.SkippedTiersFiller
	}
	// skip: schemaIsCorrectlyDefined is readOnly
	toSerialize["allowUpperCaseLettering"] = o.AllowUpperCaseLettering
	return toSerialize, nil
}

type NullableItemNumberSchemaDto struct {
	value *ItemNumberSchemaDto
	isSet bool
}

func (v NullableItemNumberSchemaDto) Get() *ItemNumberSchemaDto {
	return v.value
}

func (v *NullableItemNumberSchemaDto) Set(val *ItemNumberSchemaDto) {
	v.value = val
	v.isSet = true
}

func (v NullableItemNumberSchemaDto) IsSet() bool {
	return v.isSet
}

func (v *NullableItemNumberSchemaDto) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableItemNumberSchemaDto(val *ItemNumberSchemaDto) *NullableItemNumberSchemaDto {
	return &NullableItemNumberSchemaDto{value: val, isSet: true}
}

func (v NullableItemNumberSchemaDto) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableItemNumberSchemaDto) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
